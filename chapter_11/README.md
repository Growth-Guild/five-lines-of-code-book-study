# Chapter 11. 코드 구조 따르기

## 11.1 범위와 출처에 따른 구조 분류
* 소프트웨어 개발에서는 여러 유형의 구조(인식 가능한 패턴)을 다룬다.
* 코드가 있는 경우
  * 팀 간 - 외부 API
  * 팀 내 - 데이터와 함수, 대부분의 리팩터링
* 사람에 있는 경우
  * 팀 간 - 조직도, 프로세스
  * 팀 내 - 행위 및 도메인 전문가
* 매크로 아키텍처는 팀 간 구조에 관한 것이다.
  * 제품이 무엇이며 다른 코드가 그것과 어떻게 상호작용 하는가에 대한 것이다.
  * 외부 API가 어떻게 보여야 하는지, 각 팀이 어떤 데이터를 소유하는지를 보여주며 소프트웨어 플랫폼을 정의한다.
* 마이크로 아키텍처는 팀 내 구조에 관한 것이다.
  * 팀이 가치를 제공하기 위해 무엇을 할 수 있는지, 어떤 서비스를 사용하는지, 데이터를 어떻게 구성할지, 그리고 코드를 어떻게 작성할지 등이다.
* 도메인 전문가는 패턴에 익숙한데, 도메인의 패턴은 특정 행위를 반복하기 때문에 전무낙들은 이런 패턴에 익숙하다.
  * 전문가들은 소프트웨어가 어떻게 동작해야 하는지를 정의한다. 즉, 시스템은 전문가의 행위를 반영한다.
* 조직 구성과 그 조직이 만든 시스템 구조는 닮는 경향이 있는데, 이를 콘웨이 법칙이라고 한다.
* 사용자의 행위 또한 코드 구조에 영향을 미친다.

## 11.2 행위를 코드화하는 세 가지 방법
* 행위의 출처가 어디인지와 상관없이 행위를 코드에 반영하는 데는 세 가지 방법이 있다.
  * 제어 흐름
  * 데이터 구조
  * 데이터 자체

### 11.2.1 제어 흐름에 행위 코드화하기
* 제어 흐름은 제어 연산자, 메서드 호출, 또는 단순히 열거된 코드의 줄을 통해 행위를 텍스트로 표현한다.
* 코드 중복에 대해 이야기할 때마다 거의 항상 행위를 코드화한 이 세 가지 범주 사이를 오가면서 일반적으로 가장 오른쪽 유형인 열거된 반복적인 코드 줄의 유형을 지양하는 것에 대해 이야기한다.
* 제어 흐름 안에 행위를 기술하면 단순히 여기저기 문장을 이동하는 것만으로도 흐름을 변경할 수 있기 때문에 커다란 변화를 만들기 쉽다.
  * 흔히 우리는 안정성과 작은 변화를 선호하기 때문에 제어 흐름을 사용해 리팩터링하지 않는다.
  * 그러나 어떤 상황에서는 큰 조정이 필요한데, 동작을 제어 흐름으로 리팩터링한 다음, 이를 다시 리팩터링하는 것이 유용할 수 있다.
  * 몇 가지 예를 들면 메서드 추출(P3.2.1) 및 if 문 결합(P5.2.1)이다.

### 11.2.2 데이터 구조에 행위 코드화하기
* 행위를 기술하는 또 다른 방법은 데이터 구조를 사용하는 것이다.
  * 이를 예시로 들 수 있는 데이터 구조는 이진 검색 트리다.
* 클래스로 타입 코드 대체 및 전략 패턴의 도입 리팩터링 패턴은 모두 구조를 제어 흐름에서 데이터 구조로 옮긴다.

### 11.2.3 데이터에 행위 코드화하기
* 업계에서는 중복된 데이터로 데이터를 구조화하는 것을 흔히 볼 수 있다.
  * 이는 데이터가 변경 가능할 경우 일관성 문제로 이어질 수 있다.
  * 성능 향상은 이런 문제를 정당화할 수 있지만 오류의 원인이 될 수 있다.

## 11.3 구조 노출을 위한 코드 추가
* 리팩터링은 현재 구조를 강화하고 유사한 변경 사항을 더 잘 수용할 수 있게 한다.
* 기본 구조에 대한 확신이 없다면 리팩터링 노력을 줄이고 먼저 정확성에 집중해야 한다.
  * 따라서 비지역적인 불변속성은 피해야 한다.
  * 리팩터링을 연기할 때 의도치 않게 다른 곳에 영향을 미치지 않도록 리팩터링 되지 않은 코드를 캡슐화해야 하지만 변형점을 추가해서는 안 된다.
  * 변형점은 변형이 용이한 대신 복잡성을 증가시키기 때문이다.
* 새로운 기능이나 하위 시스템을 구현할 때는 불확실성이 있기 마련이다.
  * 이런 상황에서는 빠르게 변경할 수 있도록 클래스보다는 열거형이나 루프를 사용하느 ㄴ것이 좋다.

## 11.4 예측 대신 관찰, 그리고 경혐적 기술 사용
* 확장 가능하거나, 일반화된 무언가를 만들어야 할 경우처럼 더 어려운 문제를 해결하거나 명석함을 뽐낼 기회를 발견하면 자신의 통찰력을 사용하려고 한다.
  * 더 멋진 코드를 작성하는 데 무시할 수 있는 정도의 시간이 걸린다면 그렇게 하고 싶은 마음이 들 수 있다.
  * 그러나 그 일반화된 코드가 사용될지에 관한 확신이 없다면 불필요한 코드와 우발적 복잡성만 더할 수도 있다.
* 변경되지 않으면 아무것도 하지 않는 것이 좋다.
* 예측할 수 없이 변경되는 경우 취약성을 피하기 위해서만 리팩터링을 수행해야 한다.
* 그렇지 않으면, 과거에 발생한 변경 유형을 적용해 리팩터링해야 한다.

## 11.5 코드를 이해하지 않고도 안전성을 확보하는 방안
### 11.5.1 테스트를 통한 안전성 확보
* 안전을 확보하기 위한 가장 일반적인 접근 방식은 코드를 테스트하는 것이다.
* 정확성을 확인하는 것뿐만 아니라 사용자 입장에서 공감해보기 위해 그렇게 해야 한다.

### 11.5.2 숙달을 통한 안전성 확보
* 사람이 리팩터링을 하는 것에 초점을 맞추어 실수 가능성을 줄여 안전성을 확보할 수 있다.
* 먼저 리팩터링을 작은 단계로 분할한다.
  * 작을수록 문제가 될 위험이 사라진다.
  * 단계가 충분히 작으면 일부 단계를 놓칠 위험으로 문제가 전환된다.
  * 연습을 통해 이런 위험을 줄일 수 있다.

### 11.5.3 도구의 지원을 통한 안전성 확보
* 기계적인 면에서 보면 인적 요소를 제거해서 인간의 실수를 줄일 수 있다.
* 최신 IDE 에는 리팩터링 기능이 내장되어 있으므로 메서드를 추출하는 단계를 실행하는 대신 편집 도구에게 이를 수행하게 하는 것이 가능하다.

### 11.5.4 공식 인증을 통한 안전성 확보
* 비행기나 화성 탐사선과 같이 실패 비용이 아주 많이 드는 소프트웨어를 만드는 경우라면 극단적이지만 버그가 없는지 공식적으로 확인할 수 있다.
* 증명 보조기(proof assistant)를 사용해서 프로그램의 논리적인 명제가 올바른지 기계저긍로 확인할 수도 있다.

### 11.5.5 내결함성을 통한 안전성 확보
* 오류가 발생하더라도 자체 수정하도록 코드를 작성할 수 있다.
  * 한 가지 예로, 토글 기능이 있다. (실패 시 자동 롤백하도록 하는 토글 기능)

## 11.6 활용되지 않는 구조 이용
### 11.6.1 추출 및 캡슐화에 공백 활용
* 개발자는 문장, 필드 등을 머릿속에서 그룹화하기 때문에 빈 줄을 사용해서 지각된 구조를 표현할 때가 많다.
  * 사이에 공백을 넣어 그룹화된 문장을 볼 때마다 메서드 추출 패턴을 생각해봐야 한다.
  * 개발자가 처음 코드를 작성할 때부터 메서드로 추출하는 것이 좋겠지만 이는 노력이 필요하다.
* 공백 줄으 ㄹ사용하는 두 번째 일반적인 위치는 필드를 그룹화하는 데 사용되는 경우다.
  * 이 경우 공백은 어떤 데이터 요소가 더 관련이 있는지를 나타낸다.
  * 이 또한 데이터 캡슐화 리팩터링 패턴을 통해 이 구조를 활용하는 연습을 할 수 있다.

### 11.6.2 통합에 중복 코드 활용
* 보유한 메서드가 동일하면 해당 클래스도 동일하기 때문에 하나만 남기고 삭제할 수 있다.
* 캡슐화한 클래스들이 단순히 유사한 경우나 클래스들이 중복된 것을 볼 때마다 유사 클래스 통합 패턴을 사용해 통합할 수 있다.
* 문장의 제어 흐름은 유사한데, 문장 자체가 다른 경우에는 전략 패턴을 도입해서 동일하게 할 수 있다.

### 11.6.3 캡슐화로 공통 접사 활용
* 데이터, 메서드 및 클래스의 구조를 찾는 또 다른 방법은 매우 명확하고 신뢰할 수 있기 때문에 공통 접사를 사용하지 말 것이라는 규칙까지 존재한다.
* 주석이 있는 빈 줄과 마찬가지로 그룹으로 판단할 수 있으며 그룹의 이름으로도 활용할 수 있다.
* 공백이나 중복, 또는 이름에 공통적인 명칭을 통해 그룹화된 것을 발견할 때 이 구조를 견고하게 하는 방법은 데이터 캡슐화이다.

### 11.6.4 동적 실행으로 런타임 유형 활용
* 객체지향 프로그래밍은 인터페이스를 통한 동적 실행이라는 강력한 메커니즘이 내장되어 있기 때문에 런타임 타입을 검사하는 기능 없이 고안되었다.
* 인터페이스를 사용해서 다양한 타입의 클래스를 변수에 넣을 수 있다.
