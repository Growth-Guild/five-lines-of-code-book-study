# Chapter 7. 컴파일러와의 협업
- - -
* 컴파일러와 함께 정확성에 대한 책임을 공유함으로써 컴파일러가 소프트웨어를 제대로 빌드하는 데 도움이 되게 해야한다.
* 위험한 불변속성을 최소한으로 유지하기 위해 노력하고 경고를 포함한 컴파일러의 출력 결과에 귀를 기울여야 한다.

## 7.1 컴파일러에 대해 알아보기
### 7.1.1 약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다.
* 런타임 동안 어떤 일이 일어날지 정확히 말할 수 없는 이유를 정지 문제(halting problem)이라고 한다.
  * 프로그램을 실행하지 않고는 어떻게 동작할지 알 수 없다는 의미다.
* 경우에 따라 컴파일러는 런타임 중 실패를 포함해서 예상대로 동작하지 않는 프로그램이라고 해도 허용한다.
* 다른 경우로, 프로그램이 안전하다고 보장할 수 없는 경우 컴파일러는 프로그램을 허용하지 않는다. 이를 보수적 분석이라고 한다.

### 7.1.2 장점: 도달성 검증은 메서드의 반환을 보장한다.
* 보수적인 분석 중 하나는 메서드가 모든 경우에서 반환(return)되는지 확인하는 것이다.
* 타입스크립트에서는 열거형의 모든 값을 처리하지 않아도 문제는 없지만 아래와 같은 코드로 원하는 동작을 할 수 있다.
```typescript
enum Color {
  Red,
  Green,
  Blue
}
function assertExhausted(x: never): never {
    throw new Error("Unexpected object: " + x);
}
function handle(t: Color) {
    if (t === Color.RED) return "#ff0000";
    if (t === Color.GREEN) return "#00ff00";
    assertExhausted(t);
}
```
* 위 예시 코드에서는 never 키워드 때문에 컴파일러는 assertExhausted가 실행되는 경우가 있는지 없는지를 분석한다.
  * 컴파일러는 열거형의 모든 값을 확인하지 않았다는 것을 알아낸다.
* 형식화된 함수형 언어에서는 이를 완전 검사(exhaustiveness check)라고 한다.
* 코틀린은 sealed 키워드를 활용하면 더 간결하게 완전 검사가 가능하다.

### 7.1.3 장점: 확정 할당은 초기화되지 않은 변수에 대한 접근을 막는다.
* 컴파일러는 변수가 사용되기 전에 변수에 값이 확실히 할당되었는지 여부를 알아내는 데 능하다.
* 확정 할당 분석이 적용되는 읽기 전용 필드를 사용해서 컴파일러에게 알릴 수 있다.

### 7.1.4 장점: 접근 제어로 데이터 캡슐화를 지원한다.
* 멤버를 비공개로 하면 오용되지 않을 것이라는 것을 확신할 수 있다.

### 7.1.5 장점: 타입 검사기는 속성을 보증한다.
* 컴파일러는 타입 검사를 지원한다.
* 타입 검사를 통해 변수와 멤버가 존재하는지 확인하는 역할을 한다.
  * 이러한 기능을 이용하여 오류를 발생하도록 하여 안전하게 리팩토링을 진행할 수 있다.
* 프로그래밍 언어의 타입 검사의 강도는 스펙트럼과 같다.

### 7.1.7 약점: null을 역참조하면 애플리케이션이 손상된다.
* 스펙트럼의 다른 쪽 끝은 null이다.
  * null로 메서드를 호출하려고 하면 오류가 발생하기 때문에 위험하다.
* nullable 변수에 대한 null 검사를 하지 않는다면 null로 보는 것이 좋다.
  * 너무 적게 확인하는 것보다는 너무 많이 확인하는 것이 낫다.

### 7.1.7 약점: 산술 오류는 오버플로나 손상을 일으킨다.
* 컴파일러가 일반적으로 확인하지 않는 것은 0으로 나누기(또는 나머지) 연산이다. 컴파일러는 오버플로될 수 있는지 여부도 확인하지 않는다.
  * 이를 산술 오류(arithmetic errors)라고 한다.
* 산술 연산을 할 때 컴파일러는 큰 도움이 되지 않기 때문에 주의해야 한다.

### 7.1.8 약점: 아웃-오브-바운드 오류는 애플리케이션을 손상시킨다.
* 컴파일러가 확인하지 않는 경우는 직접 데이터 구조에 접근할 때이다.
  * 데이터 구조의 범위 내에 있지 않은 인덱스에 접근하려고 하면 아웃-오브-바운드(out of bounds) 오류가 발생한다.
* 이 문제를 피하기 위해서는 두 가지 해결책이 있다.
  * 기대하는 요소를 찾이 못할 위험이 있는 경우 전체 데이터 구조를 탐색한다.
  * 요소가 확실하게 있음을 증명하기 위해 확정 할당에 대한 방식으로 접근한다. (읽기 전용 필드를 사용해서 컴파일러에게 알리는 방식.)

### 7.1.10 약점: 교착 상태 및 경쟁 상태로 인해 의도하지 않은 동작이 발생한다.

### 7.2.1 컴파일러 활용
* 컴파일러를 TODo 리스트로 사용해 안전성을 확보
  * 변경하고 싶을 때 원래 메서드 이름을 바꾸고 컴파이럴에 의존하면 다른 모든 곳에서 우리가 해야할 일을 알 수 있다.
* 순서 강제화를 이용한 안전성 확보
  * 순서 강제화 패턴은 프로그램의 불변속성에 대해 컴파일러에게 알려주는 데 집중해서 불변속성을 일반 속성으로 만든다.
  * 컴파일러가 컴파일할 때마다 속성이 항상 유지되도록 보장하기 때문에 이후로 불변속성이 실수로 깨지는 일은 없게 된다.
* 캡슐화 강제를 통한 안전성 확보
  * 컴파일러의 접근 제어를 사용해서 불변속성을 지역화하여 엄격한 캡슐화를 강제한다.
* 컴파일러로 사용하지 않는 코드 감지
* 확정 값을 통한 안전성 확보
  * 읽기 전용 필드를 활용해서 컴파일러의 확정 할당 분석에 의존하여 안전성을 확보할 수 있다.
```typescript
interface NonEmptyList<T> {
    head: T;
}
class Last<T> implements NonEmptyList<T> {
    constructor(public readonly head: T) {}
}
class Cons<T> implements NonEmptyList<T> {
    constructor(
        public readonly head: T,
        public readonly tail: NonEmptyList<T> {}
    )
}
```

### 7.2.2 컴파일러와 싸우지 말 것
* 형 변환
  * 형 변환은 컴파일러가 사용자를 돕지 못하게 하고 기본적으로 특정 변수나 표현식에 대해 비활성화한다.
  * 형 변환을 하는 일반적인 위치는 웹 서비스에서 형식화되지 않은 JSON을 얻을 때이다.
* 동적 타입
  * 동적 유형을 사용하면 타입 검사기를 비활성화하게 된다.
  * 타입스크립트에서는 any를 사용한다.
* 런타임 타입
  * 런타임 타입은 컴파일 시간에서 런타임으로 판단에 필요한 정보를 옮긴다.
  * 예를 들면 Map에 담아 어떤 키가 있는지 알 수 없게 만들어서 판단할 수 있는 정보를 없애는 것이다.
* 기본값
  * 기본값을 사용하는 곳마다 결국 다른 누군가가 기본값으로 넣지 말아야 할 값을 추가하고 수정하는 것을 잊어버릴 수 있다.
  * 이를 해결하기 위해 기본값을 제공하지 않고 컴파일러가 개발자에게 결정을 내리도록 강제하는 것이다.
* 상속
  * 상속은 기본값의 한 형태다. 
  * 상속은 구현 클래스 간의 결합을 가져온다.
* 처리를 강제하지 않은 예외
  * 예외는 처리를 강제한 예외와 처리가 강제되지 않은 예외로, 두 가지 형태로 나타난다.
  * 처리를 강제한 예외(Checked Exception)는 호출자에게 예외가 처리되지 않았음을 알려준다.
  * 처리를 강제하지 않은 예외(Unchecked Exception)는 어떤 불변속성이 항상 참인 것을 알고 있지만 더 이상 코드로 제어할 수 없을 때와 같이 일어날 수 없는 일에 대해서만 강제하지 않는 예외다.
* 아키텍처
  * getter와 setter로 캡슐화를 깨면 수신측과 필드 사이에 결합이 만들어지고 컴파일러가 접근을 제어하지 못하게 된다.
