# Chapter 12. 최적화 및 일반화 회피

## 12.1 단순성 추구
* 인간의 인지 능력은 제한적이기 때문에 단순함은 필수다.
* 코드를 다룰 때 우리의 인지능력을 빠르게 채우는 것은 두 가지다.
  * 한 번에 두 컴포넌트를 머릿속에 유지해야 하는 서로 결합된 컴포넌트와 기능을 이해하기 위해 추적해야 하는 불변속성이 그것이다.
* 코드를 작업할 때는 불변속성을 이용한 최적화를 염두해야 한다.

## 12.2 일반화의 시기와 방법
* 메서드나 클래스에 일반화를 추가하기 전에 그렇게 해야 하는 이유가 있어야 한다.

### 12.2.1 구현의 최소화로 일반화 지양하기
* 복제, 변환, 통합의 3단계 방법은 기능이 최소한인 경우에만 최소한의 일반화를 보장한다.
  * 우리는 최소한으로 구축하기 위해 끊임없이 노력해야 한다.
* 무언가를 만들기 위해서는 먼저 컨택스트, 즉 구현하려는 동작의 범위를 이해해야 한다.
* 보수적으로 요구된 대로만 구축하는 또 다른 이유는 소프트웨어가 발전함에 따라 요구사항이 변경되는 경향이 있으므로 불필요한 일반화를 구현하고 유지하는 데 드는 노력이 쉽게 무효화될 수 있기 때문이다.

### 12.2.3 불필요한 일반화 제거
* 원하지 않는 일반화를 제거하기 위해 메서드 전문화와 삭제 후 컴파일하기 리팩터링 패턴을 사용할 수 있다.
* 불필요한 일반화를 찾는 좀 더 효과적인 방법은 함수에 전달된 런타임 인자들을 모니터링하는 것이다.
  * 객체를 합리적으로 직렬화할 수 있다면 매개변수를 기록하는 코드를 추가하는 것은 간단하다.
  * 그런 다음 각 메서드의 최신 N개의 호출을 검사하고 일부 매개변수가 항상 동일한 값으로 호출되는지 확인할 수 있으며, 매개변수에 따라 메서드 전문화를 적용할 수 있다.

## 12.3 최적화 시기와 방법
* 높은 인지부하의 또 다른 일반적인 원인은 최적화이다.
* 일반화와 마찬가지로 어떤 일을 하기 전에 그 필요성이 납득되어야 한다.
* 최적화가 필욯란 이유를 찾기 위해 항상 자동 성능 테스트를 설정하고 테스트가 실패할 때만 최적화하는 것이 좋다.
  * '이 메서드는 14ms 안에 종료되어야 한다.' -> 이런 유형을 벤치마크 테스트라고 한다.
  * '이 서비스는 초당 1000개의 요청을 처리할 수 있어야 한다.' -> 부하 테스트에서는 처리량을 검증한다.
  * '이 테스트를 실행하면 마지막으로 실행했을 때보다 10% 이상 느려지지 않아야 한다.' -> 성능 승인 테스트를 통해 성능이 갑자기 저하되지 않는지 확인한다.

### 12.3.1 최적화 전 리팩터링
* 최적화가 필요하다는 것이 입증되면 이후 유지보수 시 인지 부담을 최소화하는 방법을 알아야 한다.
  * 첫 번째 단계는 코드가 적절하게 리팩터링되었는지 확인하는 것이다.
    * 최적화는 불변속성에 의존하기 때문에 이는 잘 분해된 코드를 최적화하는 것이 더 쉽다는 것을 의미한다.

#### 컴파일러에게 맡기기
* 코드를 좋게 만드는 또 다른 이유는 컴파일러가 더 나은 코드를 생성하도록 지속적으로 돕기 때문이다.
* 피해야 할 것은 복잡한 코드를 관리하거나 특이한 패턴과 해결책을 통해 창의성을 입증함으로써 똑똑해 보이려는 사람들의 욕망이다.

### 12.3.2 제약 이론에 따른 최적화
* 코드를 리팩터링한 후에도 테스트가 여전히 만족스럽지 않으면 최적화해야 한다.
* 스레드나 프로세스, 서비스의 협업을 통해 동시 시스템에서 작업하는 경우 제약 이론이 적용된다.
  * 제약이론은 기업 시스템의 목적 달성 을 저해하는 '제약 요인'을 발견하고, 그것을 극복하기 위한 시스템 개선 수법이다.
* 병목 현상을 최적화하면 새로운 병목 현상에 맞닥뜨릴 수 있다.
  * 다운스트림 작업자가 이전 병목 현상의 증가된 처리량을 따라가지 못하거나 업스트림 작업자가 이전 병목 현상 때만큼 출력을 빠르게 생성하지 못할 수 있다.
  * 소프트웨어는 리소스 풀링이라는 해결책이 있다.
    * 리소스 풀링은 사용 가능한 모든 리소스를 필요할 때 사용할 수 있는 공용 풀에 배치하는 것을 의미한다.

### 12.3.3 측정 지표를 사용한 최적화
* 리소스 풀링으로 시스템 최적화한 후에도 성능 요구사항을 충족하지 못하면 병목 지점 내에서 최적화해야 한다.
* 가장 중요한 영향을 미칠 부분의 코드에 노력을 집중해야 하는데, 그렇게 하려면 코드에서 핫스팟을 식별해야 한다.
  * 핫스팟은 스레드가 대부분의 시간을 보내는 지점이다.
* 메서드가 핫스팟이 되는 데는 두 가지 요인이 있다.
  * 완료까지 시간이 걸리는 메서드와 루프 내부에 있는 메서드이다.
* 프로파일링이란 메서드에서 얼마나 많은 누적 시간을 소비했는지 추적하는 것을 의미한다.
  * 프로파일링을 통해 핫스팟을 식별하고 최적화하자.

### 12.3.4 좋은 알고리즘과 데이터 구조 선택하기
* 병목 컴포넌트의 핫스팟을 찾았으면 이를 최적화하는 방법을 생각해야 한다.
  * 가장 안전한 최적화 방법은 하나의 데이터 구조를 동등한 인터페이스를 가진 다른 데이터 구조로 바꾸는 것이다.
  * 이 최적화는 새로운 데이터 구조에 적응하기 위해 도메인에 관련된 코드를 변경할 필요가 없기 때문에 안전하다.
* 성능 테스트는 저하된 성능을 즉시 포착하는데, 이때 데이터 구조나 알고리즘을 전환하는 것은 쉽다.
  * 개발자가 기존 데이터 구조 또는 알고리즘 중에서 선택할 때는 동작을 살펴보는 것이 좋다.
  * 직접 구현하는 경우 핫스팟에 있지 않는 한 구현의 용이성을 먼저 생각해야 한다.

### 12.3.5 캐시 사용하기
* 캐시는 멱등 불변속성과 조합될 때 가장 안전하다.
  * 동일한 인자로 호출하면 동일한 결과가 제공되어야 한다.
* 멱등성이 없어도 캐시를 수행할 수 있지만 내부적이어야 한다.
  * List 클래스의 size 를 재계산하지 않기 위해 total 필드를 유지하는 것이 그 예시다.

### 12.3.6 최적화된 코드 분리하기
* 알고리즘, 동시성 및 캐시로 성능 테스트를 만족시키는 데 불충분한 경우는 거의 없다.
* 불충분한 경우 마이크로 최적화라고도 하는 성능 튜닝으로 전환한다.
  * 튜닝의 예는 매직 비트 패턴을 사용하는 것이다.

#### 잠금 영역 최소화를 위한 메서드와 클래스 사용
* 일반적으로 까다로운(즉, 인지 비용이 많이 드는) 튜닝된 함수를 이해하지 않고는 이를 크게 변경할 수는 없다.
  * 따라서 코드는 기본적으로 잠겨있다.
  * 따라서 튜닝된 코드를 격리해야 한다.
  * 튜닝이 효과를 바루히하기 위해서는 잠가야 하는 코드의 양을 최소화해야 한다.
  * 튜닝에 데이터가 포함된 경우 클래스를 사용해서 데이터를 분리해야 한다. 또는 별도의 메서드로 추출할 수 있다.

#### 향후 개발자들에게 알리기 위한 패키지 사용
* 미래의 개발자들에게 이 코드가 튜닝되어 있으므로 자세히 다루지 말라는 사실을 전달함으로써 이익을 얻을 수 있다.
* 튜닝된 코드를 위한 전용 패키지를 사용하는 것이 좋다.
  * 이는 임포트해서 사용할 패키지가 보이지 않게 되기 때문이다.
