# Chapter 9. 코드 삭제의 미학
* 시간이나 노력을 들였기 때문에 어떤 것에 가치를 부여하는 것을 매몰 비용의 오류라고 한다.
* 가치는 투자 자체에서 나오는 것이 아니라 투자의 결과에서 나온다.
* 코드 자체는 보유하고 있는 한 비용이다.

## 9.2 복잡성을 제거하기 위한 코드 삭제
* 커다란 코드베이스는 커플링으로 인해 더 복잡한 모델이 필요하고 추적을 위한 더 큰 유틸리티 라이브러리가 필요하다.
* 복잡성은 도메인 복잡성과 부수적 복잡성이라는 두 가지 유형으로 나뉜다.
  * 도메인 복잡성은 도메인이 기본적으로 가지고 있는 것이다. 즉, 우리가 해결하고 있는 문제는 본질적으로 복잡하다.
  * 부수적 복잡성은 도메인에서 요구하지 않았지만 우연히 추가된 모든 복잡성을 말한다.
* 부수적 복잡성은 일반적으로 기술부채의 동의어로 사용되지만, 아래의 네 가지 유형으로 조금 더 세밀하게 나누어 볼 수 있다.
  * 경험상 기술적 무지
  * 기술적 낭비
  * 기술적 부채
  * 기술적 방해물

### 9.2.1 경험 부족으로 인한 기술적 무지
* 무의식적으로 코드에서 잘못된 결정을 내림으로써 좋지 않은 아키텍처를 만든다.
* 우리가 정말 모르거나 배울 시간이 없기 때문에 불필요한 결합을 추가하지 않고도 문제를 해결할 수 있는 기술이 부족해서 발생한다.
* 이 문제의 유일하게 지속 가능한 해결책은 애자일 소프트웨어 개발을 위한 선언문에 있는 원칙 중 하나에서 찾을 수 있다.
> 기술적 우수성과 우수한 설계에 지속적으로 주의를 기울이면 민첩성이 향상됩니다. - 애자일 소프트웨어 개발을 위한 선언문 -

### 9.2.2 시간 압박으로 인한 기술적 낭비
* 기술적 낭비는 코드에서 잘못된 결정을 내림으로써 아키텍처가 좋지 않은 결과를 초래하는 것이다.
* 훨씬 더 일반적인 기술 낭비는 시간 압박에서 비롯된다.
* 문제나 모델을 충분히 이해하지 못하기 때문에 테스트나 리팩터링을 건너뛰기도 하고, 기한을 맞추기 위해 프로세스를 우회하기도 한다.
* 이런 나쁜 결정은 의도적인 것이다. 개발자는 외부 압력으로 인해 더 나은 지식을 거스르는 방향을 선택하게 된다.
* 해결책은 개발자에게 모범 사례를 건너뛸 기회가 전혀 없게 하는 것이다.

### 9.2.3 환경에 따른 기술적 부채
* 기술적 무지와 낭비는 모두 제거될 수 있고 제거돼야 하는 반면, 기술 부채는 약간 다르다.
* 기술 부채는 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것이다.
  * 의도적인 의사결정이지만 중요한 것은 일시적이라는 것이다.
* 기술 부채를 발생시키는 것은 전략적인 결정이며, 만료일이 있는 한 본질적으로 잘못된 것은 아니다.

### 9.2.4 성장에 따른 기술적 장애물
* 개발을 더디게 만드는 모든 것이다.
  * 문서, 테스트 및 실존하는 모든 코드는 물론 다른 모든 범주가 포함된다.
* 자동화된 테스트는 테스트 코드도 의도적으로 변경해야 하므로 코드를 변경하기 어렵게 만든다.
  * 일반적으로 빠른 것보다 느리고 안정적인 것을 선호하는 중요 시스템에 있어서는 반드시 나쁜 것은 아니다.
  * 반면에 스파이크를 수행하는 것과 같은 높은 수준의 실험이 도움이 되는 상황에서는 그 반대가 된다. (스파이크가 뭐여..)
* 문서는 무언가를 변경할 때 반드시 업데이트해야 하기 때문에 개발 속도를 늦춘다.
* 변경 사항이 나머지 애플리케이션에 어떤 영향을 미칠지를 고려해야 하고 유지보수하는 데 시간 비용이 들기 때문에 코드 자체도 기술적 장애물이다.
* 기술적 장애물은 무언가 구축하는 데 따르는 부작용이다.
  * 그 자체로는 나쁘지 않지만 드물게 사용되는 문서, 기능 또는 코드를 유지보수하는 상황에서는 나쁘다.
  * 이런 경우 방해를 없애기 위해 기능을 제거하는 것이 경제적으로 유리할 수 있다.
* 해결책은 더 이상 삭제할 것이 없을 때까지 가능한 한 많은 것을 삭제하는 것이다.

## 9.3 친밀도에 따른 코드 분류
* 우리는 최근에 개발한 코드에 가장 익숙하다.
* 시간 비용으로 따지면 우리가 친밀하게 알고 있는 코드를 삭제하는 것이 이해를 먼저 해야 하는 코드를 삭제하는 것보다 저렴하고 안전하다.

## 9.4 레거시 시스템에서의 코드 삭제
* 레거시 코드의 일반적인 정의는 '수정하기 겁나는 코드'다.
* 이 상황은 종종 서커스 팩터의 결과다.
* 서커스 팩터는 프로젝트를 진행하는 팀원 중 얼마나 많은 사람이 갑작스럽게 빠져야 프로젝트가 중단되거나 심각한 상황에 놓이는지를 가리키는 지표다.
* 우리는 생산성을 위해 코드에 익숙해질 필요가 있으며 코드에 대한 책임을 질 필요가 있는데, 코드가 취약하거나 알 수 없는 경우에는 그럴 수가 없다.

### 9.4.1 스트랭글러 무화과나무 패턴
* 해결책의 첫 번째는 레거시 코드가 얼마나 사용되고 있는지 확인하는 것이다.
  * 거의 사용되지 않는 경우 추가 조사 없이 제거할 수 있다.
  * 작은 부분만 많이 사용하는 경우라면 해당 부분만 수정하고 나머지는 제거할 수 있다.
  * 모든 것이 많이 사용된다면 코드에 익숙해져서 안정적으로 만들어야 한다.
* 레거시 코드에 대한 통찰력을 얻으려면 각 부분이 얼마나 호출되는지, 얼마나 많은 호출이 성공했는지 알아야 한다.
* 레거시 코드가 나머지 소프트웨어와 얼마나 밀접하게 연결되어 있는지 알아야 한다.
* 스트랭글러 무화과놔무 패턴은 기존 나무 줄기에 씨를 뿌리고 자라면서 숙주를 감싸 궁극적으로 숙주 나무를 교살해 죽이는 나무의 이름을 따온 것이다.
* 이 비유에서 숙주는 레거시 시스템이고, 이 패턴은 다음과 같은 예시로 진행된다.

### 9.4.2 코드 개선을 위한 스트랭글러 무화과나무 패턴 사용
* 어떤 항목이 호출되는 빈도는 일반적으로 그것이 얼마나 중요한지를 나타내는 좋은 지표다.
* 가장 많이 호출되는 부분은 거의 확실히 마이그레이션되어야 하고, 가장 적게 호출되는 부분은 높은 확률로 삭제될 수 있으므로 이런 잔가지들을 먼저 처리하고 어려운 결정이 있는 몸통으로 이동하는 것이 좋다.
* 레거시 코드의 해당 부분을 리팩토링해서 결합과 취약성을 제거하고 코드를 '최신'으로 분류한다. 또는 해당 부분을 다시 만들고 다시 만들어진 코드가 준비되면 게이트를 변경해서 새 버전으로 전환할 수 있다.
* 일부 레거시 코드가 중요하지 않고 전략적이지 않은 경우 게이트에서 메서드를 삭제한다.

## 9.5 동결된 프로젝트에서 코드 삭제
### 9.5.1 바람직한 결과를 기본값으로 설정
* 프로젝트가 코드베이스 외부에 영향을 미치지 않는 경우
  * 메인 브랜치에서 코드를 되돌리고 별도의 브랜치에 넣을 수 있다.
  * 그런 다음, 태그를 지정하고 6주 후에 태그를 삭제한다고 메모를 작성해야 한다. (6주 안에 프로젝트를 사용하지 않으면 그것은 제거될 것이라는 의미다.)
* 프로젝트가 코드 외적인 변경 사항이 포함된 경우
  * 제거할 모든 구성 요소를 프로젝트 관리 도구에 기록해두고 티켓을 6주로 예약한다. (이런 일이 발생하면 자주 사용되는 구성요소의 유형을 설정하고 해제하는 스크립트를 만드는 것이 좋다.)
* 두 경우 모든 사람이 조취를 취하지 않으면 코드가 사라진다.

### 9.5.2 스파이크와 스태빌라이즈(안정화)로 낭비 줄이기
* 이 패턴에서 프로젝트를 스파이크로 취급한다.
* 가능한 프로젝트를 일반 애플리케이션과 별도로 구현하고 고품질에 노력을 기울이지 않는다. (자동화된 테스트와 리팩터링이 없다는 것이다.)
  * 하지만 모니터링이 포함되어 코드가 얼마나 사용되고 있는지 알 수 있다.
* 6주 후에 코드로 돌아가 얼마나 사용되는지 확인한다.
  * 많이 사용되었다면 그것을 재구현한다. (이번에는 고품질에 주의를 기울인다.)
  * 그렇지 않으면 삭제한다.
* 스파이크가 이미 메인 시스템과 최소한의 통합을 가지고 있기 때문에 코드를 제거하는 시간이 절약된다.
* 코드가 사용되는지 여부를 알지 못한 채 코드를 리팩터링하거나 테스트하는 데 소비되는 시간도 절약할 수 있다.

## 9.6 버전 관리에서 브랜치 삭제
* 브랜치를 만드는 여러 목적 중에 주요 이유는 다음과 같다.
  * 긴급 패치(hotfix)를 수행하기 위해
  * 커밋에 태그를 지정하면 release처럼 해당 위치로 되돌아갈 수 있다.
  * 다른 사람의 업무를 방해하지 않고 일하기 위해
* 첫 번째와 세 번째는 메인 브랜치에 병합되면 삭제되어야 한다.
* 두 번째 이유는 대신 Git의 기본 제공 방법을 사용해야 한다.
* 메인 브랜치와 릴리스 브랜치만 있는 것이 바람직하며, 다른 모든 브랜치는 최적의 경우 며칠만 생존해 있어야 한다.
  * 수명이 긴 브랜치를 사용하면 비용이 더 들고 혼돈을 야기하며 오류가 발생하기 쉬운 병합 출돌에 노출된다.
  * 필요하지 않은 브랜치는 더 많은 필요 없는 브랜치를 만들어낸다.

### 9.6.1 브랜치 제한으로 낭비 최소화
* 이 문제를 해결하기 위해 개발을 효과적으로 관리하고 수행할 수 있는 협업 방법인 칸반을 적용할 수 있다.
* 칸반은 진행 중인 작업(WIP, work in progress) 제한 개념을 사용한다.
  * WIP 제한은 팀이 진행할 수 있는 티켓 수에 대한 상한선이 정해져 있다.
  * 이렇게하면 WIP 한계에 도달해서 업스트림 사람들이 새로운 작업을 시작하지 못하기 때문에 개발에서의 병목 현상을 노출하는 데 도움이 된다.
  * 업스트림 사람들이 새로운 티켓을 시작할 수 없는 경우 병목현상을 조사해서 이를 해결할 방법을 찾을 것을 권장한다. 
* 너무 많은 브랜치의 문제는 병목현상 문제와 정확히 맞아떨어지기 때문에 동일한 해결책을 사용할 수 있다.
  * 브랜치 수에 대한 엄격한 제한을 도입하는 것이다.
  * 모든 사람이 동시에 작업할 수 있는 제한은 최소한 워크스테이션 수와 같아야 한다.
  * 한계가 정해지면 팀 규모가 바뀔 때를 제외하고는 어떤 이유도 깨지거나 바뀌어서는 안된다.

## 9.8 테스트 코드 삭제
### 9.8.1 낙관적 테스트 삭제
* 테스트의 필수 속성 중 하나는 신뢰를 갖게 만드는 것이다.
* 그린 테스트를 통해 코드의 동작을 신뢰할 수 있어야 한다. 따라서 테스트는 무언가를 시험해야 한다.
* 실패할 수 없는 테스트는 가치가 없다.
* 실패한 테스트는 코드에서 오류를 발견할 때 유용하다.

### 9.8.2 비관적 테스트 삭제
* 레드 테스트는 무엇인가에 문제가 존재하고 우리가 그것을 수정할 필요가 있다는 것을 의미한다.
  * 이것이 테스트 실패에 대한 허용 오차가 0이어야 하는 이유다.
* 항상 레드인 테스트를 한다면 테스트에서 오류가 발견되더라도 경보 피로를 느껴 중대한 오류를 놓칠 위험이 있다.

### 9.8.3 불안정 테스트 수정 또는 삭제
* 낙관적 테스트와 비관적 테스트는 모두 극단적이어서 항상 통과하거나 항상 실패한다.
* 항상 같은 결과를 내지 않는 예측할 수 없는 레드 또는 그린 테스트가 있는데, 이를 불안정 테스트라고 한다.
* 낙관적 테스트와 비관적 테스트와 마찬가지로 테스트를 몇 번 더 실행하는 것을 제외하면 어떤 조치도 끌어내지 않는다.

### 9.8.4 복잡한 테스트를 제거하기 위한 코드 리팩터링
* 섬세한 설정이 필요하거나 많은 중복을 가진 테스트로 구성되어서 이를 리팩터링하거나 복잡한 테스트 셋을 만들어야 하는 경우가 있다.
* 이런 테스트는 우리가 코드를 단순화하고 불변속성을 지역화하는 등의 좋은 코드를 만드는 작업을 수행하는 것이라서 가치 있는 일을 하고 있다고 느끼기 때문에 위험하다.
* 테스트를 리팩터링해야 한다는 것은 테스트 중인 코드에 적절한 아키텍처가 없다는 신호다.
* 모든 리팩터링 노력은 테스트가 아니라 코드에 집중돼야 한다.

### 9.8.5 속도를 높이는 테스트 문화
* 느린 테스트와 빠른 테스트를 분리하고 가능한 한 자주 빠른 테스트를 지속적으로 실행하거나 느린 테스트의 실패 원인을 관찰하고 관련이 없는 경우 제거하는 것이 좋다.

## 9.9 설정 코드 삭제
* 코드베이스를 늘리지 않고도 사용자 수를 늘릴 수 있을 때 설정성은 소프트웨어의 유용성을 높일 수 있다.
* 설정이 가능한 플래그 형태로 제공되면 배포와 릴리스를 분리해서 배포 빈도를 높이고 릴리스할 때 기술적인 결정 대신 사업적인 결정을 내릴 수 있다.
  * 그러나 설정을 추가할 때마다 코드의 복잡성도 증가한다.
  * 대부분의 경우 각 옵션을 모든 플래그에 대해 테스트해야 하기 때문에 테스트 양이 두 배로 증가한다.

### 9.9.1 설정의 예상 수명으로 범위 지정
#### 실험을 위한 설정
* 실험적인 설정의 예로 기능 플래그가 있는데, 이들은 기능이 출시된 후 제거될 것이다.
  * 간단한 작업인지 확인하기 위해 앞서 설명한 것처럼 6주 내에 완료돼야 한다.
* 또 다른 실험적인 설정의 예로, 변경 사항이 우수한지 여부를 테스트하는 데 사용하는 베타 테스트(또는 A/B 테스트)가 있다.
  * 기능 플래그와는 목적이 다른데, 설정을 통해 일부 사용자는 변경 사항을 경험할 수 있지만 다른 사용자는 그렇지 않다.
  * 변경사항이 원하는 효과를 얻을 수 있는지 측정할 수 있다.
* 실험을 위한 설정이 실험 단계를 넘어서 영구적인 설정이 되면서 복잡성만 증가시키는 경향이 있는데, 이런 문제를 예방하기 위해서 무엇을 실험하기 위한 설정인지를 처음부터 결정하고 테스트가 완료되는 즉시 제거하라는 알람을(6주 이내로 유지) 생성해야 한다.

#### 과도기적인 설정
* 과도기적인 설정은 비즈니스 또는 코드베이스가 주용 변경 사항을 겪고 있는 동안 유용하다.
  * 예를 들어, 레거시 시스템에서 새로운 시스템으로 전환하는 것을 들 수 있다.
* 이러한 대규모 변경이 6주 이내 끝날 것이라고 예상하거나 강제할 수 없기 때문에 장기적으로 복잡성이 증가하고 높은 비용을 치러야 한다.
* 그러나 긴 전환에는 일반적으로 활용할 수 있는 두 가지 특성이 있다.
  * 첫 번째
    * 많은 유형의 전환이 사용자에게는 잘 보이지 않으므로 릴리스와 배포를 연결하는 것으로 만족할 수 있다. 즉, 설정을 코드 외부가 아닌 내부에 코드의 일부로 포함시킬 수 있다.
    * 코드에 포함한다는 것은 나머지와 분리된 중앙의 어떤 지점에서 전환과 관련된 모든 설정을 모을 수 있다는 것을 의미한다.
  * 두 번째
    * 일반적으로 전환이 완료되고 오래된 부분을 제거할 수 있는 위치가 있다. 이를 활용하면 코드를 다듬고 소소한 부분을 삭제하는 데 시간을 낭비하지 않고 전체 작업이 완료될 때까지 기다릴 수 있다.
    * 안전하게 진행하기 위해서 스트랭글러 무화과나무 패턴을 사용해서 레거시 구성요소에 대한 모든 접근을 차단해야 한다.
